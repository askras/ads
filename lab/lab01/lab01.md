---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.0
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```python slideshow={"slide_type": "skip"}
from wand.image import Image as WImage
```


# Лабораторная работа 1. Методы сортировки

**Цель работы:** ознакомление с алгоритмами сортировки линейных и нелинейных структур и методикой оценки эффективности алгоритмов.

**Продолжительность работы:** - 4 часа. 

**Мягкий дедлайн (10 баллов)**: 18.03.2023 

**Жесткий дедлайн (5 баллов)**: 01.04.2023


## Теоретические сведения

**Сортировкой (sorting problem)** множества элементов называется расположение этих элементов по возрастанию или убыванию в соответствии с определенным отношением линейного порядка. 
Обычно рассматривается отношение естественного порядка, когда элементы располагаются по возрастанию. 

С упорядоченными элементами проще работать, чем с произвольно расположенными: легче найти необходимые элементы, исключить, вставить новые. 
Сортировка применяется при организации наборов данных на внешних носителях, при создании библиотек, каталогов, баз данных и т.д.

Формально задача сортировки определяется следующим образом. 
Дано конечное множество $Х_n = \{x_1, x_2, \ldots, x_n\}$, которое будем называть *массивом*. 
Требуется найти перестановку $P= \{p_1, p_2, ..., p_n\}$ этих $n$ элементов, которая отобразит данный массив (множество $X_n$) в неубывающую последовательность $x_{p_1} \leqslant x_{p_2} \leqslant \ldots \leqslant x_{p_n}$. 
Как правило, алгоритмы сортировки вырабатывают саму упорядоченную последовательность, а не упорядочивающую перестановку $P$.

В общем случае элементы массива могут иметь сложную структуру, но с каждым элементом ассоциирован некоторый
ключ (имя), используемый для того, чтобы отличить один элемент от другого. 
Поскольку рассматривается прежде всего процесс сортировки ключей, идентифицирующих каждый элемент, а
остальные компоненты не влияют на упорядочивающую функцию, будем считать, что элементами массива являются имена
(ключи).


### Классификация алгоритмов сортировки



#### Устойчивость (стабильность)

Алгоритм сортировки называется **устойчивым (stable)**, если он сохраняет исходный порядок равных имен. 
Данное свойство важно в тех случаях, когда элементы уже упорядочены по какому-то вторичному ключу и необходимо провести сортировку по первичному ключу (не зависящему от вторичного) так, чтобы внутри групп с одинаковыми первичными ключами сохранялся порядок, определяемый вторичным ключом. 

![Устойчивый алгоритм сортировки](./img/stable_sort.jpg)

Если алгоритм сортировки не обладает свойством устойчивости (**неустойчивый (unstable)**), то эту задачу придется решать, сортируя элементы по составному ключу, являющемуся объединением первичного и вторичного ключей.

![Неустойчивый алгоритм сортировки](./img/unstable_sort.jpg)


```python
img = WImage(filename='./img/stable_sort.pdf')
img
```


#### Место хранения данных

Выделяют два вида сортировки: внутреннюю и внешнюю.
**Внутренняя сортировка (Internal sorting)** решает задачу полной сортировки для случая достаточно малого массива, умещающегося непосредственно в оперативной памяти. 
**Внешняя сортировка (External sorting)** решает задачу полной сортировки для случая такого большого массива, не умещающегося в оперативной памяти, что доступ к нему организован по частям, расположенным на внешних запоминающих устройствах.


```python
img = WImage(filename='./img/internal_sort.pdf')
img
```


#### Выделение дополниетльного места

Если алгоритм перемещает элементы внутри исходного массива, то говорят, что выполняется сортировка **на месте (on place)**.
Сортировка, которая использует дополнительное пространство равное или большее исходному, называется сортировкой **не на месте**.


```python
img = WImage(filename='./img/onplace_sort.pdf')
img
```


#### Адаптивность

Алгоритм сортировки называется **адаптивным**, если он использует преимущества уже «отсортированных» элементов в списке, который должен быть отсортирован. 
То есть при сортировке, если в исходном списке уже есть какой-то элемент, адаптивные алгоритмы примут это во внимание и постараются не переупорядочивать их.

**Неадаптивный** алгоритм – это алгоритм, который не учитывает элементы, которые уже отсортированы. 
Они пытаются принудительно переупорядочить каждый элемент, чтобы подтвердить их сортировку. 


```python
img = WImage(filename='./img/adapt_sort.pdf')
img
```


#### Сложность

Естественной мерой оценки временной сложности алгоритма сортировки массива $X_n$ являются:

  - количество сравнений (обозначим $C(n)$);
  - количество перемещений элементов (обозначим $M(n)$).
  
При этом оценку желательно проводить по количеству операций, выполняемых в лучшем, среднем и худшем случаях.


```python
img = WImage(filename='./img/complexity_sort.pdf')
img
```

#### Методы сортировки

```python
img = WImage(filename='./img/method_sort.pdf')
img
```

## Варианты заданий

| Вариант | n1     | n2     | n3     | n4     | Метод сортировки          |
|:------- |:-------|:-------|:-------|:-------|:--------------------------|
|  1      | 1000   | 5000   | 10000  | 100000 | Медленная сортировка      |
|  2      | 1000   | 5000   | 10000  | 100000 | Сортировка слиянием       |
|  3      | 1000   | 5000   | 10000  | 100000 | Метод Шелла               |
|  4      | 1000   | 5000   | 10000  | 100000 | Быстрая (Хоара)           |
|  5      | 1000   | 5000   | 10000  | 100000 | Шейкерная сортировка      |
|  6      | 1000   | 5000   | 10000  | 100000 | Сортировка расческой      |
|  7      | 1000   | 5000   | 10000  | 100000 | Гномья сортировка         |
|  8      | 1000   | 5000   | 10000  | 100000 | Сортировка чёт-нечет      |
|  9      | 1000   | 5000   | 10000  | 100000 | Поразрядная сортировка    |
| 10      | 1000   | 5000   | 10000  | 100000 | Сортировка Деревом        |
| 11      | 1000   | 5000   | 10000  | 100000 | Топологическая сортировка |
| 12      | 1000   | 5000   | 10000  | 100000 | Timsort                   |
| 13      | 1000   | 5000   | 10000  | 100000 | Bogosort                  |
| 14      | 1000   | 5000   | 10000  | 100000 | Stooge sort               |
| 15      | 1000   | 5000   | 10000  | 100000 | Сеть сортировки           |
| 16      | 1000   | 5000   | 10000  | 100000 | Блинная сортировка        |
| 17      | 1000   | 5000   | 10000  | 100000 | Битонная                  |
| 18      | 1000   | 5000   | 10000  | 100000 | Introsort                 |
| 19      | 1000   | 5000   | 10000  | 100000 | Блочная сортировка        |
| 20      | 1000   | 5000   | 10000  | 100000 | Сортировка подсчетом      |
| 21      | 1000   | 5000   | 10000  | 100000 | Сортировка слиянием       |
| 22      | 1000   | 5000   | 10000  | 100000 | Сортировка выбором        |
| 23      | 1000   | 5000   | 10000  | 100000 | Пирамидальная сортировка  |
| 24      | 1000   | 5000   | 10000  | 100000 | Плавная сортировка        |
| 25      | 1000   | 5000   | 10000  | 100000 | Сортировка перемешиванием |
| 26      | 1000   | 5000   | 10000  | 100000 | Пузырьковая сортировка    |

1. Провести классификацию алгоритма.
2. Подготовить теоретическое описание алгоритма сортировки согласно номеру индивидуального варианта.
3. Подготовить блок-схему алгоритма.
4. Представить описание алгоритма на псевдокоде.
5. Описать достоинства и недостатки алгоритма.
6. Реализовать алгоритм сортировки согласно номеру индивидуального варианта. 
7. Протестировать корректность реализации алгоритма
8. Провести ручную трассировку алгоритма.
9. Провести сравнение указанных алгоритмов сортировки массивов, содержащих n1, n2, n3 и n4 элементов. 
10. Каждую функцию сортировки вызывать трижды: для сортировки упорядоченного массива, массива, упорядоченного в обратном порядке и неупорядоченного массива. Сортируемая последовательность для всех методов должна быть одинаковой (сортировать копии одного массива). 
11. Проиллюстрировать эффективность алгоритмов сортировок по заданному критерию. Построить диаграммы указанных зависимостей.


## Литература

Дональд Э. Кнут. Искусство программирования, том 2. Получисленные алгоритмы = The Art of Computer Programming, vol.2. Seminumerical Algorithms, 3-ed. — Вильямс, 2007. — С. 832. — ISBN 978-5-8459-0081-4.

Роберт Седжвик. Фундаментальные алгоритмы на C. Анализ/Структуры данных/Сортировка/Поиск = Algorithms in C. Fundamentals/Data Structures/Sorting/Searching. — СПб.: ДиаСофтЮП, 2003. — С. 672. — ISBN 5-93772-081-4.
